3.8 zdk :
我看了一下好像有一些问题。首先是可视化一开始出错了只会显示最后一个时间步的状态，我给他修好了还加
了一个拖拽栏方便观察。然后原来的逻辑里Level(灾情登记）和need rescue（需要救援的总时间）这两个
变量和逻辑和判断成功的逻辑不太对。我修改为仅有need rescue先到0才算成功。

发现原来在救援执行时，同时减少了两个值：
disasters[(target_x, target_y)]["level"] -= rescuer["capacity"] - 减少灾情严重程度
disasters[(target_x, target_y)]["rescue_needed"] -= 1 - 减少所需救援次数
现在修改为在救援执行时只减少rescue_needed。当 level=0 时，表示灾情自然结束了
但如果此时 rescue_needed 不为 0，说明灾情没有得到成功救助

3.10sjy：
改了一下救援人员的救援能力，使得救援能力强的先去重灾区

3.10zdk:
救援执行逻辑中，无论救援人员的capacity是多少，每次救援都是将灾情点的rescue_needed减1。
也就是说，当前系统中救援人员的capacity参数实际上没有被使用。

目前，level 和 rescue_needed 是独立随机生成的，没有关联性。修改为level越大，rescue_needed越大

修改了救援执行逻辑，使得救援人员的capacity参数被正确使用。救援能力强的先去重灾区。
计算能力匹配度：灾情点的rescue_needed与救援员capacity的比例，越接近1越好
                    capacity_match = min(
                        rescuer.get("capacity", 1) / task["data"].get("rescue_needed", 1),
                        1.0
                    )
                    
                    # 新的评分公式：结合灾情等级、能力匹配度和距离
                    score = (task["data"]["level"] * capacity_match) / (distance + 1)

首先救援成功率改为统计过去30个时间步中的成功率而不是全局成功率。
然后救援成功率的可视化与过程可视化一起显示且和拖拽条功能适配

在环境和灾情点中添加时间步信息。
修改environment.py中灾情点创建和初始化的部分，
确保每个灾情点记录其创建和结束时间步
保持向后兼容性，当没有提供时间步时仍可使用所有灾情

统计窗口大小的参数添加到配置文件中，方便地进行调整。

修改rescue_dispatch.py文件，在评分公式中加入对救援者移动速度的考虑。
改轻，中度灾情的排序逻辑，让它考虑到达时间而不仅仅是距离。

继续改进正确率统计的逻辑，现在正确率统计只考虑已完成灾情点：统计时只考虑已经完成（成功或失败）的灾情点，完全忽略进行中的灾情点。
窗口大小N现在明确指的是"最近N个已完成的灾情点"，而不是"最近N个时间步中的灾情点"
使得救援成功率的计算更加准确和有意义，特别是在灾情点稀疏或大部分灾情点仍在进行中的情况下。